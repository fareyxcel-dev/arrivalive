<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Maldives SkyView - Unified Reflection</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
<style>
    :root {
        --rain-color: rgba(10, 40, 60, 0.6);
        --ripple-color: rgb(80, 120, 140);
        --ripple-opacity: 0.2;
    }

    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; height: 100%; width: 100%; touch-action: none; font-family: sans-serif; }
    
    #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    #celestial-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 10; pointer-events: none;
        -webkit-mask-image: linear-gradient(to bottom, black 0%, black 65%, transparent 72%);
        mask-image: linear-gradient(to bottom, black 0%, black 65%, transparent 72%);
    }

    #reflection-layer {
        position: absolute; 
        top: 72%; left: 0; width: 100%; height: 28%; 
        z-index: 20; overflow: hidden; pointer-events: none;
        mix-blend-mode: screen; 
        filter: url(#water-ripple) blur(0.4px);
    }
    
    .reflection-column {
        position: absolute; top: 0; transform: translate(-50%, 0); 
        display: flex; flex-direction: column; align-items: center;
        width: 300px; height: 100%;
        -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
        mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
    }

    .glitter-line {
        height: 2px; margin-bottom: 2px; border-radius: 100%; 
        background-color: currentColor; box-shadow: 0 0 6px currentColor;
        will-change: transform, width, opacity; transition: opacity 0.5s ease;
    }

    #sun-visual { position: absolute; width: 250px; height: 250px; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; transition: opacity 2s ease; }
    .sun-core { width: 42px; height: 42px; border-radius: 50%; z-index: 3; background: #fff; box-shadow: 0 0 30px rgba(255,255,255,0.8); }
    .sun-glow-inner { position: absolute; width: 120px; height: 120px; border-radius: 50%; z-index: 2; }
    .sun-glow-outer { position: absolute; width: 100%; height: 100%; border-radius: 50%; z-index: 1; animation: atmosPulse 8s infinite alternate ease-in-out; }
    @keyframes atmosPulse { from{opacity:0.3; transform:scale(0.9);} to{opacity:0.6; transform:scale(1.1);} }
    #moon-visual { position: absolute; width: 45px; height: 45px; transform: translate(-50%, -50%); filter: drop-shadow(0 0 10px rgba(255,255,255,0.3)); transition: opacity 2s ease; }
    
    #weather-grade {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 22; pointer-events: none;
        transition: backdrop-filter 2s ease, background-color 2s ease;
    }

    #rain-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 25; pointer-events: none; display: none; overflow: hidden;
        -webkit-mask-image: linear-gradient(to bottom, transparent 0%, rgba(0,0,0,1) 15%);
        mask-image: linear-gradient(to bottom, transparent 0%, rgba(0,0,0,1) 15%);
    }
    
    .rain-drop {
        position: absolute;
        background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(150, 160, 170, 0.15) 50%, var(--rain-color));
        width: 1px; height: 60px; top: -100px; 
        animation: rainfall linear infinite;
    }

    #ripple-layer {
        position: absolute; top: 72%; left: 0; width: 100%; height: 28%;
        z-index: 24; pointer-events: none; display: none; overflow: hidden;
        perspective: 500px;
    }

    .ocean-ripple {
        position: absolute;
        border-radius: 50%;
        border: 2px solid var(--ripple-color); 
        background: transparent;
        transform: scaleY(0.2); opacity: 0;
        animation: rippleExpand 2s linear forwards;
        -webkit-mask-image: repeating-linear-gradient(to bottom, black 0%, black 20%, transparent 20%, transparent 40%);
        mask-image: repeating-linear-gradient(to bottom, black 0%, black 20%, transparent 20%, transparent 40%);
    }

    @keyframes rainfall { 0% { transform: translateY(-100px); } 100% { transform: translateY(120vh); } }

    @keyframes rippleExpand {
        0% { width: 10px; height: 10px; opacity: var(--ripple-opacity); border-width: 3px; transform: scaleY(0.2) translateY(0); }
        100% { width: 150px; height: 150px; opacity: 0; border-width: 0px; transform: scaleY(0.2) translateY(-200px); }
    }

    #storm-flash {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: white; opacity: 0; z-index: 26; pointer-events: none;
        transition: opacity 0.05s ease-out; mix-blend-mode: screen;
    }

    #shooting-star {
        position: absolute; width: 2px; height: 2px; background: white; border-radius: 50%;
        box-shadow: 0 0 4px white; opacity: 0; z-index: 9; pointer-events: none;
    }
    #shooting-star::after {
        content: ''; position: absolute; top: 50%; right: 0; transform: translateY(-50%);
        width: 40px; height: 1px;
        background: linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,0.8));
    }
    @keyframes shoot {
        0% { transform: translateX(0) translateY(0) rotate(-35deg); opacity: 1; width: 2px; }
        100% { transform: translateX(-150px) translateY(100px) rotate(-35deg); opacity: 0; width: 0; }
    }
</style>
</head>
<body>
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;">
        <defs><filter id="water-ripple"><feTurbulence id="turb-noise" type="fractalNoise" baseFrequency="0.01 0.8" numOctaves="2" result="noise" /><feDisplacementMap in="SourceGraphic" in2="noise" scale="12" xChannelSelector="R" yChannelSelector="G" /><feGaussianBlur stdDeviation="0.6" /></filter></defs>
    </svg>
    <div id="canvas-container"></div>
    <div id="celestial-layer">
        <div id="sun-visual"><div class="sun-core" id="sun-core"></div><div class="sun-glow-inner" id="sun-inner"></div><div class="sun-glow-outer" id="sun-outer"></div></div>
        <div id="moon-visual"><svg viewBox="0 0 100 100" overflow="visible"><defs><mask id="mMask"><rect x="-50" y="-50" width="200" height="200" fill="white"/><circle id="mShadow" cx="150" cy="50" r="48" fill="black"/></mask></defs><circle cx="50" cy="50" r="48" fill="#eef2f7" mask="url(#mMask)"/></svg></div>
        <div id="shooting-star"></div>
    </div>
    <div id="reflection-layer"><div id="reflection-content"><div id="sun-reflection-col" class="reflection-column"></div><div id="moon-reflection-col" class="reflection-column"></div></div></div>
    <div id="weather-grade"></div><div id="rain-layer"></div><div id="ripple-layer"></div><div id="storm-flash"></div>

<script id="vert" type="x-shader/x-vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }</script>
<script id="frag" type="x-shader/x-fragment">
precision highp float;
varying vec2 vUv;
uniform float iTime;
uniform vec2 iRes;
uniform float iDay;
uniform vec3 iSunDir;
uniform vec3 iMoonDir;
uniform float uCloudDensity;

float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float noise(vec2 p){ vec2 i=floor(p), f=fract(p); vec2 u=f*f*(3.-2.*f); return mix(mix(hash(i),hash(i+vec2(1,0)),u.x), mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),u.x), u.y); }
float fbm(vec2 p){ float v=0., a=.5; mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5)); for(int i=0;i<5;i++){ v+=a*noise(p); p=rot*p*2.0+vec2(1.3); a*=.5; } return v; }

vec3 verticalGradient(float y, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7) {
    float t = y * 6.0;
    if (t < 1.0) return mix(c1, c2, smoothstep(0.0, 1.0, t));
    if (t < 2.0) return mix(c2, c3, smoothstep(0.0, 1.0, t - 1.0));
    if (t < 3.0) return mix(c3, c4, smoothstep(0.0, 1.0, t - 2.0));
    if (t < 4.0) return mix(c4, c5, smoothstep(0.0, 1.0, t - 3.0));
    if (t < 5.0) return mix(c5, c6, smoothstep(0.0, 1.0, t - 4.0));
    return mix(c6, c7, smoothstep(0.0, 1.0, t - 5.0));
}
void getNightPal(out vec3 c[7]) { c[0]=vec3(0.0,0.0,0.02); c[1]=vec3(0.01,0.01,0.05); c[2]=vec3(0.01,0.02,0.08); c[3]=vec3(0.02,0.03,0.1); c[4]=vec3(0.01,0.02,0.08); c[5]=vec3(0.,0.,0.05); c[6]=vec3(0.,0.,0.02); }
void getRisePal(out vec3 c[7]) { c[0]=vec3(0.4,0.1,0.0); c[1]=vec3(1.0,0.3,0.05); c[2]=vec3(1.0,0.6,0.2); c[3]=vec3(0.5,0.6,0.8); c[4]=vec3(0.2,0.4,0.7); c[5]=vec3(0.1,0.2,0.5); c[6]=vec3(0.05,0.1,0.3); }
void getDayPal(out vec3 c[7]) { c[0]=vec3(0.7,0.9,1.0); c[1]=vec3(0.5,0.8,0.95); c[2]=vec3(0.3,0.65,0.9); c[3]=vec3(0.1,0.5,0.85); c[4]=vec3(0.05,0.35,0.8); c[5]=vec3(0.02,0.2,0.6); c[6]=vec3(0.01,0.1,0.4); }
void getSetPal(out vec3 c[7]) { c[0]=vec3(0.5,0.0,0.1); c[1]=vec3(0.9,0.2,0.1); c[2]=vec3(1.0,0.5,0.2); c[3]=vec3(0.6,0.3,0.5); c[4]=vec3(0.3,0.2,0.5); c[5]=vec3(0.1,0.1,0.4); c[6]=vec3(0.02,0.02,0.2); }

vec3 getSkyColor(float mu) {
    vec3 c[7], p1[7], p2[7]; float t = iDay; float mf = 0.0;
    if (t < 0.26) { getNightPal(p1); getNightPal(p2); } 
    else if (t < 0.28) { getNightPal(p1); getRisePal(p2); mf = smoothstep(0.26, 0.28, t); }
    else if (t < 0.30) { getRisePal(p1); getDayPal(p2); mf = smoothstep(0.28, 0.30, t); }
    else if (t < 0.73) { getDayPal(p1); getDayPal(p2); }
    else if (t < 0.75) { getDayPal(p1); getSetPal(p2); mf = smoothstep(0.73, 0.75, t); }
    else if (t < 0.77) { getSetPal(p1); getNightPal(p2); mf = smoothstep(0.75, 0.77, t); } 
    else { getNightPal(p1); getNightPal(p2); }
    for(int i=0; i<7; i++) c[i] = mix(p1[i], p2[i], mf);
    vec3 base = verticalGradient(pow(mu, 0.7), c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
    float dome = pow(max(0.0, dot(iSunDir, vec3(0.0, mu, 0.0))), 3.0);
    return base + (c[1] * dome * 0.4);
}

void main(){
    vec2 uv = (gl_FragCoord.xy - 0.5 * iRes.xy) / iRes.y; uv.y += 0.35;
    vec3 rd = normalize(vec3(uv, -1.0)); rd.yz = mat2(cos(-0.12), sin(-0.12), -sin(-0.12), cos(-0.12)) * rd.yz;
    vec3 bg = getSkyColor(clamp(rd.y, 0.0, 1.0)); vec3 col = bg;

    float starVis = (1.0 - smoothstep(-0.2, 0.1, iSunDir.y)) * smoothstep(0.0, 0.4, rd.y);
    if(rd.y > 0.0 && starVis > 0.0) {
        vec2 sc = (rd.xz / (rd.y + 0.1) + vec2(iDay * 20.0, 0.0)) * 200.0; vec2 id = floor(sc);
        if(hash(id) > 0.997) { float tw = 0.5 + 0.5 * (1.0 - smoothstep(0.0, 0.01, abs(fract(iDay * 24.0) - hash(id + 10.0)))); col += vec3(tw) * starVis; }
    }

    if(rd.y > 0.0) {
        float skyY = max(0.0, rd.y); vec2 cUV = rd.xz / (skyY + 0.2) + vec2(iTime * 0.03, iTime * 0.01);
        float den = smoothstep(1.0 - uCloudDensity, 1.6 - uCloudDensity, fbm(cUV * 1.5 + fbm(cUV * 0.5)));
        float sDist = max(0.0, dot(rd, iSunDir));
        vec3 hCol = mix(vec3(0.2,0.2,0.3), mix(vec3(1.0,0.6,0.3), vec3(1.0), smoothstep(0.1, 0.4, iSunDir.y)), smoothstep(-0.2, 0.1, iSunDir.y));
        vec3 sCol = mix(vec3(0.02,0.02,0.05), mix(vec3(0.4,0.2,0.4), vec3(0.85,0.9,0.95), smoothstep(0.1, 0.4, iSunDir.y)), smoothstep(-0.2, 0.1, iSunDir.y));
        col = mix(col, mix(sCol, hCol, den * 0.6 + sDist * 0.4), den * smoothstep(0.0, 0.3, skyY));
    }

    if(rd.y < 0.0) {
        float d = -3.0 / rd.y; vec3 pos = vec3(0.0, 3.0, 0.0) + rd * d; float e = 0.02;
        vec2 wUV = pos.xz * 0.2 + vec2(iTime * 0.2, iTime * 0.12);
        vec3 n = normalize(vec3(fbm(wUV)-fbm(wUV+vec2(e,0)), e*10., fbm(wUV)-fbm(wUV+vec2(0,e))));
        vec3 oBase = mix(vec3(0.01, 0.03, 0.1), vec3(0.0, 0.25, 0.45), smoothstep(-0.2, 0.2, iSunDir.y));
        vec3 refl = mix(oBase, getSkyColor(clamp(reflect(rd, n).y, 0.0, 1.0)), pow(1.0 - max(dot(-rd, n), 0.0), 12.0));
        col = mix(refl, bg, 1.0 - exp(-d * 0.015));
    }
    gl_FragColor = vec4(col, 1.0);
}
</script>
<script>
    const CONFIG = { lat: 4.17, lon: 73.51 }; 
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const scene = new THREE.Scene();
    
    const uniforms = {
        iTime: { value: 0 }, iRes: { value: new THREE.Vector2() }, iDay: { value: 0.5 },
        iSunDir: { value: new THREE.Vector3() }, iMoonDir: { value: new THREE.Vector3() },
        uCloudDensity: { value: 0.6 }
    };
    
    scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.ShaderMaterial({
        vertexShader: document.getElementById('vert').textContent,
        fragmentShader: document.getElementById('frag').textContent,
        uniforms: uniforms
    })));

    function resize() { renderer.setSize(window.innerWidth, window.innerHeight); uniforms.iRes.value.set(window.innerWidth, window.innerHeight); }
    window.addEventListener('resize', resize); resize();
    
    function lerpColor(a, b, t) { return a.map((val, i) => val + (b[i] - val) * t); }
    const turb = document.getElementById('turb-noise'); let noiseSeed = 0;

    const sCol = document.getElementById('sun-reflection-col'); const mCol = document.getElementById('moon-reflection-col');
    const LINE_COUNT = 55; const sunLines = [], moonLines = [];

    function initLines(container, array) { for(let i=0; i<LINE_COUNT; i++) { const line = document.createElement('div'); line.className = 'glitter-line'; container.appendChild(line); array.push(line); } }
    initLines(sCol, sunLines); initLines(mCol, moonLines);

    function updateReflectionVisuals(linesArr, alt, colorRGB, time, type) {
        if (alt < -6) { linesArr.forEach(l => l.style.opacity = 0); return; }
        let mainOpacity = (type === 'sun') ? Math.min(Math.max((alt + 6) / 10, 0), 0.85) : Math.min(Math.max((alt + 5) / 10, 0), 0.4);
        const altitudeSpread = 0.3 + (alt / 90) * 0.7;
        linesArr.forEach((line, i) => {
            const p = i / LINE_COUNT; 
            const n1 = Math.sin(time * 2 + i * 0.5); const n2 = Math.cos(time * 5 + i * 1.3); const noiseVal = (n1 + n2) * 0.5;
            let width = (10 + p*100) * altitudeSpread * (0.8 + 0.4 * noiseVal); width = Math.max(5, Math.min(100, width));
            let alpha = mainOpacity * (0.5 + 0.5 * noiseVal); let drift = Math.sin(time + p * 10) * (20 * p); 
            line.style.width = width + '%'; line.style.opacity = alpha;
            line.style.transform = `translateX(${drift}px)`; line.style.color = `rgba(${colorRGB[0]}, ${colorRGB[1]}, ${colorRGB[2]}, ${alpha})`;
        });
    }

    let weatherMode = 'auto'; let stormInterval = null; let rippleInterval = null;
    let celestialOpacitySun = 1.0; let celestialOpacityMoon = 1.0;

    function initRain() {
        const container = document.getElementById('rain-layer');
        if (container.childElementCount > 0) return;
        for(let i=0; i<250; i++) {
            let drop = document.createElement('div'); drop.className = 'rain-drop';
            let depth = Math.random(); let scale = 0.5 + depth * 0.8; let opacity = 0.2 + depth * 0.6; let duration = (0.6 + Math.random() * 0.3) / scale;
            drop.style.left = Math.random() * 100 + '%'; drop.style.width = (1 * scale) + 'px'; drop.style.height = (40 * scale) + 'px';
            drop.style.opacity = opacity; drop.style.animationDuration = duration + 's'; drop.style.animationDelay = Math.random() * -2 + 's';
            if(depth < 0.3) drop.style.filter = 'blur(1px)';
            container.appendChild(drop);
        }
    }
    initRain();

    function spawnRipples() {
        const container = document.getElementById('ripple-layer');
        const rip = document.createElement('div'); rip.className = 'ocean-ripple';
        const topVal = Math.random() * 90;
        rip.style.left = Math.random() * 95 + '%'; rip.style.top = topVal + '%';
        const progress = topVal / 90; const opacity = 0.12 + (progress * 0.11);
        rip.style.setProperty('--ripple-opacity', opacity);
        const scale = 0.5 + Math.random() * 1.0;
        rip.style.width = (50 * scale) + 'px'; rip.style.height = (50 * scale) + 'px';
        container.appendChild(rip); setTimeout(() => rip.remove(), 2000);
    }

    function setVisualWeather(type) {
        const rainLayer = document.getElementById('rain-layer'); const rippleLayer = document.getElementById('ripple-layer');
        const stormFlash = document.getElementById('storm-flash'); const grade = document.getElementById('weather-grade');
        rainLayer.style.display = 'none'; rippleLayer.style.display = 'none'; stormFlash.style.opacity = 0;
        clearInterval(stormInterval); clearInterval(rippleInterval);
        grade.style.backdropFilter = 'none'; grade.style.backgroundColor = 'transparent';
        celestialOpacitySun = 1.0; celestialOpacityMoon = 1.0;

        if (type === 'clear') { uniforms.uCloudDensity.value = 0.6; }
        else if (type === 'rain' || type === 'storm') {
            rainLayer.style.display = 'block'; rippleLayer.style.display = 'block';
            let ripFreq = type === 'storm' ? 30 : 100; rippleInterval = setInterval(spawnRipples, ripFreq);
            if (type === 'rain') {
                uniforms.uCloudDensity.value = 0.85; 
                grade.style.backdropFilter = 'saturate(0.7) contrast(0.9) brightness(0.9)'; grade.style.backgroundColor = 'rgba(50, 60, 70, 0.1)';
                celestialOpacitySun = 0.7; celestialOpacityMoon = 0.4;
            } else {
                uniforms.uCloudDensity.value = 1.1; 
                grade.style.backdropFilter = 'saturate(0.5) contrast(1.1) brightness(0.7)'; grade.style.backgroundColor = 'rgba(10, 20, 30, 0.2)';
                celestialOpacitySun = 0.15; celestialOpacityMoon = 0.06;
                stormInterval = setInterval(() => {
                    if(Math.random() > 0.96) { stormFlash.style.opacity = 0.8; setTimeout(() => stormFlash.style.opacity = 0, 80); if(Math.random() > 0.7) setTimeout(() => { stormFlash.style.opacity = 0.5; setTimeout(() => stormFlash.style.opacity = 0, 50); }, 150); }
                }, 100);
            }
        }
    }

    async function checkAutoWeather() {
        if (weatherMode !== 'auto') return;
        try {
            const res = await fetch('https://api.open-meteo.com/v1/forecast?latitude=4.1755&longitude=73.5093&current_weather=true');
            const data = await res.json(); const code = data.current_weather.weathercode;
            if (code >= 95) setVisualWeather('storm'); else if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82)) setVisualWeather('rain'); else setVisualWeather('clear');
        } catch(e) { console.error('Weather API Error', e); }
    }
    checkAutoWeather(); setInterval(checkAutoWeather, 600000);

    let nextShootingStarTime = 0;
    function scheduleNextShootingStar(nowTime) {
        const minDelay = 22 * 60 * 1000; const maxDelay = 44 * 60 * 1000;
        const delay = minDelay + Math.random() * (maxDelay - minDelay);
        nextShootingStarTime = nowTime + delay;
    }

    function animate(now) {
        requestAnimationFrame(animate);
        
        let appTime = new Date(Date.now() + (new Date().getTimezoneOffset()*60000 + 18000000));
        
        uniforms.iTime.value = now / 1000; const seconds = now / 1000;
        noiseSeed += 0.005; turb.setAttribute('baseFrequency', `0.01 ${0.8 + Math.sin(noiseSeed)*0.05}`);
        
        const sPos = SunCalc.getPosition(appTime, CONFIG.lat, CONFIG.lon);
        const mPos = SunCalc.getMoonPosition(appTime, CONFIG.lat, CONFIG.lon);
        const moon = SunCalc.getMoonIllumination(appTime);

        const sX = 50 + Math.sin(sPos.azimuth)*45; const sY = 72 - (sPos.altitude/(Math.PI/2))*60;
        const mX = 50 + Math.sin(mPos.azimuth)*45; const mY = 72 - (mPos.altitude/(Math.PI/2))*60;

        document.getElementById('sun-visual').style.left = sX + '%'; document.getElementById('sun-visual').style.top = sY + '%';
        document.getElementById('sun-visual').style.opacity = celestialOpacitySun;
        document.getElementById('moon-visual').style.left = mX + '%'; document.getElementById('moon-visual').style.top = mY + '%';

        const deg = sPos.altitude*(180/Math.PI); const mDeg = mPos.altitude*(180/Math.PI);
        let t = Math.max(0, Math.min(1, (deg + 2) / 17)); let curC = lerpColor([255, 128, 0], [255, 255, 255], t); let rgb = `rgb(${curC[0]}, ${curC[1]}, ${curC[2]})`;
        
        document.getElementById('sun-core').style.background = rgb;
        document.getElementById('sun-inner').style.background = `radial-gradient(circle, rgba(${curC[0]},${curC[1]},${curC[2]},0.6) 0%, transparent 70%)`;
        document.getElementById('sun-outer').style.background = `radial-gradient(circle, rgba(${curC[0]},${curC[1]},${curC[2]},0.15) 0%, transparent 70%)`;

        let baseMoonOpacity = Math.max(0.3, 1.0 - (deg/15));
        document.getElementById('moon-visual').style.opacity = baseMoonOpacity * celestialOpacityMoon;
        if(document.getElementById('mShadow')) document.getElementById('mShadow').setAttribute('cx', 50+(1-Math.abs((moon.phase-0.5)*2))*100);

        sCol.style.left = sX + '%'; mCol.style.left = mX + '%';
        updateReflectionVisuals(sunLines, deg, curC, seconds, 'sun');
        updateReflectionVisuals(moonLines, mDeg, [200, 230, 255], seconds, 'moon');
        
        const dayFactor = Math.min(Math.max((deg + 5) / 20, 0), 1);
        const rC = lerpColor([10, 40, 60], [230, 250, 255], dayFactor);
        document.documentElement.style.setProperty('--rain-color', `rgba(${rC[0]}, ${rC[1]}, ${rC[2]}, 0.6)`);
        const ripC = lerpColor([80, 120, 140], [220, 245, 255], dayFactor);
        document.documentElement.style.setProperty('--ripple-color', `rgb(${ripC[0]}, ${ripC[1]}, ${ripC[2]})`);
        
        uniforms.iDay.value = (appTime.getHours()*3600 + appTime.getMinutes()*60 + appTime.getSeconds()) / 86400;
        uniforms.iSunDir.value.set(Math.sin(sPos.azimuth), Math.sin(sPos.altitude), -Math.cos(sPos.azimuth));
        uniforms.iMoonDir.value.set(Math.sin(mPos.azimuth), Math.sin(mPos.altitude), -Math.cos(mPos.azimuth));
        
        const isNight = deg < -6;
        if (!isNight) { if (nextShootingStarTime !== 0) { nextShootingStarTime = 0; } } 
        else {
            const currentTime = appTime.getTime();
            if (nextShootingStarTime === 0) { scheduleNextShootingStar(currentTime); }
            if (currentTime >= nextShootingStarTime) {
                const star = document.getElementById('shooting-star');
                const startY = Math.random() * 40; const startX = 20 + Math.random() * 60; 
                star.style.top = startY + '%'; star.style.left = startX + '%';
                star.style.animation = 'none'; star.offsetHeight; star.style.animation = 'shoot 1s linear forwards';
                scheduleNextShootingStar(currentTime);
            }
        }
        renderer.render(scene, camera);
    }
    animate(0);
</script>
</body>
</html>